# exteon/docker-recipes

Library that allows merging `Dockerfile` and `docker-compose.yml` recipes, 
adding modularity and reusability to docker recipes

## Concepts

### Templates

In the context of `docker-recipes`, a template is a fragment of `Dockerfile`, 
using the same syntax, that is used to piece together a final `Dockerfile`.

A template can require multiple other templates.

### Dockerfile

With `docker-recipes`, a source dockerfile is a regular `Dockerfile`, with added
syntax to include any number of templates.

### `docker-compose.yml`

`docker-recipes` provides a mechanism for merging multiple `docker-compose.yml`s
into a destination `docker-compose.yml`. At the same time, referenced templated
`Dockerfile`s in `docker-compose.yml`s are managed to point to the generated 
`Dockerfile`s in the generated merged `docker-compose.yml`

## Dockerfile composition and syntax

In both `Dockerfile`s and templates, the syntax to require another template is:

```
#TEMPLATE[ template-name ]
```

That is, a comment starting at the beginning of the line, with a single comment
hash and followed, with no spaces, by `TEMPLATE[`. Between the square brackets,
the template name is provided. The mechanism of locating templates is described
in [Locators](#locators).

The purpose of the library is, for every source `Dockerfile`, to generate a 
target `Dockerfile` with all templates compiled in.

When a template is required multiple times, it will (presumably by multiple 
different other templates), it will be deduplicated and included only once in 
the compiled Dockerfile; the concept of functional (invokable/parameterisable) 
templates is not implemented but is considered for future versions.

In the `Dockerfile` templates/images, when you have for instance a `COPY`
instruction, you need the path to the template dir. For this, you need to use 
the `$TEMPLATE_DIR` variable which will be compiled into the proper path, i.e.:

```dockerfile
COPY $TEMPLATE_DIR/supervisord/supervisord.conf /etc/supervisord.conf
```
(see this [Example template](example/sources/default/templates/centos8/Dockerfile))

#`docker-compose.yml` composition and syntax

A final `docker-compose.yml` will be generated by merging the 
`docker-compose.yml` file returned by each locator. There is no special syntax, 
except when you need to reference the path to the final context the compose will 
run in. This is also known as "the project path" and is sent as `$sourceRoot`
to the `DockerComposeCompiler` constructor (see 
[docker-compose compiling](#docker-compose-compiling)).

To reference that directory, use the `${PROJECT_DIR}` environment variable in 
the source `docker-compose.yml` files.

(see this [example](example/sources/default/docker-compose.yml))

#<a name="locators"></a> Locators

Images and templates are referenced by name. In order to locate and map them to 
a source file, one or more locators are used. A standard locator implementation 
is provided, with classes `StdDockerfileLocator` and `StdDockerComposeLocator` 
that receives a root directory as constructor parameter; every root 
directory contains a set of templates and a set of images, and, in case of 
`StdDockerComposeLocator`, zero or one `docker-compose.yml` file. 

The file structure is as follows:

```
<root_dir>
  ├ templates
  │  ├ template_name_1
  │  │  └ Dockerfile
  │  └ some_other_template
  │     └ Dockerfile
  ├ image_name_1
  │  └ Dockerfile
  ├ some_other_image
  │  └ Dockerfile
  └ docker-compose.yml
```

The difference between the two locators is that:

* `StdDockerfileLocator` is used by `DockerfileCompiler` and will only process
  images and templates
* `StdDockerComposeLocator` is used by `DockerComposeCompiler` and will process,
  in addition to images and templates, also the `docker-compose.yml` file.

If you need a different directory structure, you can create custom locators 
implementing `DockerComposeLocator` and `DockerfileLocator` interfaces.

#<a name="dockerfile-compiling"></a> Dockerfile compiling

Compilation of images from templates is done by `DockerfileCompiler`, which is
instantiated as follows:

```php
/**
 * @param DockerfileLocator[] $locators
 * @param string $targetDir
 * @param string $sourceRoot
 */
public function __construct(
   array $locators,
   string $targetDir,
   string $sourceRoot
)
```

The `$targetDir` is a target directory where compiled image files will be 
written. 

The `$sourceRoot` is the path to a directory having the following meaning: when
a dockerfile references files under `$sourceRoot`, relative paths will be used 
in the compiled image files. Otherwise, absolute paths will be used. In effect,
most of the time `$sourceRoot` means the project root path: any paths within the 
project root will be kept relative and thus will be portable, while any paths 
outside the project root will be kept absolute and when porting the project you
need to make sure that the outside paths are still available.

To compile the images, you use:

```php
/** @var \Exteon\DockerRecipes\DockerfileCompiler $compiler */
$compiler->compile();
```

This will produce a target directory that for the example source directory 
above, will produce:

```
<target_dir>
  ├ image_name_1
  │  └ Dockerfile
  └ some_other_image
     └ Dockerfile
```

So for every source image, there will be a target image compiled from the 
templates.

#<a name="docker-compose-compiling"></a> docker-compose compiling

Compiling recipes for `docker-compose` is done using `DockerComposeCompiler`,
which compiles both images (the same as `DockerfileCompiler`, and a 
`docker-compose.yml`) file from the locators' `docker-compose.yml` files. It is
instanced as:

```php
/**
 * @param DockerComposeLocator[] $locators
 * @param string $dockerfilesTargetDir
 * @param string $composeFileTargetPath
 * @param string $sourceRoot
 * @param bool $absolutePathSourceRoot
 */
public function __construct(
    array $locators,
    string $dockerfilesTargetDir,
    string $composeFileTargetPath,
    string $sourceRoot,
    bool $absolutePathSourceRoot = false
)
```

The `$dockerfilesTargetDir` is the target directory for the compiled images. For
more info, see [Dockerfile compiling](#dockerfile-compiling).

The `$composeFileTargetPath` is the target path for the `docker-compose.yml`
file to be compiled.

The `$sourceRoot` is the path to a directory having the following meaning: when
a dockerfile or `docker-compose.yml` file references files under `$sourceRoot`, 
relative paths will be used 
in the compiled image / docker compose files. Otherwise, absolute paths will be 
used. In effect,
most of the time `$sourceRoot` means the project root path: any paths within the 
project root will be kept relative and thus will be portable, while any paths 
outside the project root will be kept absolute and when porting the project you
need to make sure that the outside paths are still available. The `$sourceRoot`
will also be used as the `context` directory for the built images.

`$absolutePathSourceRoot` overrides the behavior of `$sourceRoot`, making all 
compiled paths absolute.

To compile the images / compose files, you use:

```php
/** @var \Exteon\DockerRecipes\DockerComposeCompiler $compiler */
$compiler->compile();
```

When compiling `docker-compose.yml` from multiple sources (multiple locators 
that provide a `docker-compose.yml`), the target file is merged from all the 
source files using the following algorithm: recursively, for all string keys in 
the yml file, values are merged (or overridden if scalar). For all sequential
arrays, the contents are appended.

# Example

Since an example is worth a thousand words, you can take a look at 
the [example](example) dir to see an example of compiling a CentOS8 image with
a webserver, using templates that can be reused for building different other 
images (such as the `supervisor-rhel8` template).

To run the example, just run `php example.php`. The `centos8-web` image recipe
will be generated in `example/target` and the compose file at 
`example/docker-compose.yml`. To build and run the container, run 
`composer up -d` in `example`